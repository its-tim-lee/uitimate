---
component: form
---

<QuickDemoSection />
<VersatileTabs2 defaultValue="form-remove-app-from-project" variant="underline">
  <VersatileTabs2Content value="form-remove-app-from-project" demoId="form-remove-app-from-project" showCode={false} />
</VersatileTabs2>

<QuickStartSection />
Form-building is incredibly hard without a proper framework for both coding and guidance.
So, we provide RHF (aka. [*<u>React Hook Form</u>*](https://github.com/react-hook-form/react-hook-form)) on the coding side,
and most importantly, we'll teach you how to use it right.

<details>
<summary>**DEEP DIVE**: Why is building forms hard?</summary>

   In the front-end world, several classic applications are hard to build, including forms.
   (Frankly, compared to others, forms aren't that hard to build)
   They all share the same basic challenge when things get complex:
   - Tons of states to manage.
   - The relationship among states are complicated.

   When the number of states exceeds a certain limit, or/and when the complexity of the relationship among states is higher than a certain threshold,
   it's tough to manage them, so people create another layer of solutions for better management.
   RHF is one of several solutions in the field of form-building.

   For the framework like RHF being great and flexible,
   it's easy to run into many problems without proper guidance when working on complex forms, including:
   - Thinking RHF is incompetent and needing another framework
   - Still having too many states that are hard to manage, leading to considering adding another complexity like RxJS
   - Code seems becoming messier and more complex after using RHF
   - Having no idea how to use RHF to implement certain features
   - ...

   The takeaway here is that building a form requires choosing an appropriate framework,
   but more importantly, you need to learn how to use it correctly.
   This can be a longer journey than expected.
   <br /><br />
</details>



<details>
  <summary>**DEEP DIVE**: What's RHF?</summary>

   I think the introduction on RHF's site isn't ideal for beginners.

   So I'll explain it better here.

  Simply put: It's a headless UI framework.
  The longer answer:
   - It's more of a framework than a library because adopting it means you'll build forms in a unique way provided by RHF.
   Since it's a framework, it's quite extensive to learn, and migrating to other similar libraries won't be trivial.
   - It's also a headless UI, but it mainly provides control toolkits for form state management instead of React components.
   This makes it different from **Radix**'s approach (which offers "headless UI components"), and more similar to **TanStack Table**.
   <br /><br />
</details>

Since teaching form-building via RHF isn't trivial, learning things progressively is a must:

On this page, you'll learn the basic concepts of RHF.
Once you've mastered the fundamentals, the tutorial pages will show
how RHF can solve tough design problems while keeping everything manageable.


#### 1️⃣ Form Jargons
Understanding these jargons is critical since many APIs (including our components and RHF's documentation) and concepts refer to them frequently.

- **form control**: sometimes called "control element" - these are elements commonly used in forms such as input, textarea, select, etc.
- RHF's (API/Concept) Jargons
  - **form**:
    - The form representation managed by RHF
    - Think of it as your form's agent that lets you perform many actions (CRUD-like operations):
      - Reset all values of all form fields
      - Set a value for a specific field
      - ...
  - **form state**:
    - Stores various states of the form, including:
      - Whether the entire form is submitting
      - Which fields have been touched
      - Is the entire form valid (usually when all fields are valid)
      - ...
  - **field**: Represents a specific **form control** as data
  - **field state**:
    - Just like **form** has **form state**, **field** has **field state**
    - It maintains states specific to a certain field, such as:
      - Does the field have any errors?
      - Has the field been touched?
      - ...


#### 2️⃣ Anatomy
Typically, composing a form involves these relevant family components:

```tsx file="#/components/ui/Form/Form.anatomy.txt"
```


#### 3️⃣ Your first form
Let's look at a super simple demo:
<VersatileTabs2 defaultValue="form-damn-easy-demo" variant="underline">
  <VersatileTabs2Content value="form-damn-easy-demo" demoId="form-damn-easy-demo"/>
</VersatileTabs2>

From there, we have:
- 4 MUST-FOLLOW rules:
  - `<Form>`: MUST declare `schema` & `onSubmit` props
  - `<FormItem>`: MUST have a unique `name`
  - `<FormControl>`: MUST only have one child - the control element
  - Submit-button MUST have `type="submit"`
- `<FormLabel>`: The system automatically registers `htmlFor` for you (like what happens with [Label](./../../label/introduction))
- `<FormMessage>`: Displays hints below the form control, such as error messages or helpful tips to help users fill out the form

More details:
- `onSubmit`: Called AFTER the form is validated successfully. Form validity is determined by the `schema`
- Except for `<FormControl>`, you can put anything inside any other family components
  - For example, we put `<Cta>` as a direct child of `<Form>`

Here's the beauty of using RHF: in the demo above,
if you submit without checking the checkbox, you'll see an error message.
You don't manually validate the form - it just works against the `schema` you provided!

When submission is successful, you'll get a clean `data` object in the `onSubmit` callback -
a clear representation of "What did the user fill in?":
```ts
{
  tos: true
}
```

Everything is straightforward in the RHF world, right?
You'll explore deeper concepts in the tutorial pages.



#### 4️⃣ Before moving forward...

Before heading to the tutorial pages,
let's learn other fundamentals by exploring demos for integration with various form controls:

<VersatileTabs2 defaultValue="form-radiogroup-demo" variant="underline">
  <VersatileTabs2List>
    <VersatileTabs2Trigger value="form-radiogroup-demo">1. RadioGroup</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-input-demo">2. Input</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-select-demo">3. Select</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-switch-demo">4. Switch</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-textarea-demo">5. Textarea</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-datepicker-demo">6. DatePicker</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-combobox-demo">7. Combobox</VersatileTabs2Trigger>
    <VersatileTabs2Trigger value="form-damn-easy-demo-2">8. Checkbox</VersatileTabs2Trigger>
  </VersatileTabs2List>
  <VersatileTabs2Content value="form-radiogroup-demo" demoId="form-radiogroup-demo"/>
  <VersatileTabs2Content value="form-input-demo" demoId="form-input-demo"/>
  <VersatileTabs2Content value="form-select-demo" demoId="form-select-demo"/>
  <VersatileTabs2Content value="form-switch-demo" demoId="form-switch-demo"/>
  <VersatileTabs2Content value="form-textarea-demo" demoId="form-textarea-demo"/>
  <VersatileTabs2Content value="form-datepicker-demo" demoId="form-datepicker-demo">
    This form control is unusual as it's handled differently from others,
    and understanding it requires knowing more about how RHF works.

    The reason RHF can read or write to any field is that
    it injects these props into each form control:
    ```ts
    // copied from RHF's source code
    export type ControllerRenderProps<TFieldValues extends FieldValues = FieldValues, TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>> = {
      onChange: (...event: any[]) => void;
      onBlur: Noop;
      value: FieldPathValue<TFieldValues, TName>;
      disabled?: boolean;
      name: TName;
      ref: RefCallBack;
    };
    ```
    By injecting these, RHF can detect any change from the form control (via `onChange`), and
    it can modify values as needed (via `value`).

    The reason that you don't need to know this for other form controls is simply because
    we've integrated them well. We don't provide the same integration for datepicker
    because it's not considered a core component, but more of a recipe component,
    which is why this integration needs to be handled manually.

  </VersatileTabs2Content>
  <VersatileTabs2Content value="form-combobox-demo" demoId="form-combobox-demo">
    This just has the same integration challenge with RHF as the datepicker example, so refer the explanation there for more details.
  </VersatileTabs2Content>
  <VersatileTabs2Content value="form-damn-easy-demo-2" demoId="form-damn-easy-demo-2">

  This demo appears again for educational purposes: to show how **Zod** works with RHF.

  In this code snippet, `defaultValues` specifies the initial value of the form field.

  Without it, here's what happens:
  at the beginning, the checkbox value is actually `undefined`. Submitting at this point will trigger an error,
  but the error message will be a generic "Required" instead of what we defined in the schema.

  Why?

  Because without any value, it triggers Zod's basic validation
  instead of hitting whatever you defined in `refine`.

  Another important concept is understanding the difference between `default` in the schema and `defaultValues` in RHF:
  `defaultValues` is reflected in the UI, but `default` only potentially affects the form data.
  For example, you can define `.default(true)` on the schema without providing `defaultValues`,
  and you can submit successfully even if the checkbox isn't checked in the UI. The submitted data will be `{ tos: true }`.

  </VersatileTabs2Content>

</VersatileTabs2>

___

Let's go! For more on family components and demos showing how versatile this component can be, head to the [tutorial](./../tutorial).
Or if you're experienced enough, check out the [API reference page](./../api).

___

<QASection />
<QA2>
  <QA2Item >
    <QA2Trigger>**@uitimate/form** vs. **<u>Shadcn</u>**'s form?</QA2Trigger>
     <QA2Content>
        I believe I've encapsulated RHF so well that it'll 100% boost your DX when building forms, period.
     </QA2Content>
   </QA2Item>
  <QA2Item >
    <QA2Trigger>Why encapsulate RHF?</QA2Trigger>
     <QA2Content>
        Without good encapsulation, you'll face many boilerplates when using RHF,
        and that sucks!
     </QA2Content>
   </QA2Item>

</QA2>