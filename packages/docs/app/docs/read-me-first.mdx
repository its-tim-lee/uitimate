---
title: read-me-first
---
# Setup **<u>Uitimate</u>**

Unlike **shadcn/ui**, we have almost no installation steps with far more easier setup.
You're good to go as long as you're in a 1) React-dedicated environment (e.g., **Next**, **Remix**, ‚Ä¶) with 2) **TypeScript**, and 3) **Tailwind** v4 enabled.

So, prepare one locally, and the guide below shows you how to configure it to use **Uitimate**.

> We've prepared one for you, but note that, you still need to review all content below,
> because some of the setup are very different from the traditional sense of "installation", "configuration" or whatever in other technique documents.

### 1Ô∏è‚É£ &nbsp; Configure path alias in your project

By default, our component source code and many demo codes use file paths like:
```ts
import ... from "#/..."
```
where `#` is called an alias, and it must be configured ahead of time so that our code will work in your project.

<details className="tw:cursor-pointer">
<summary>**DEEP DIVE**: Why `#`? Why not `@`?</summary>
<div className="tw:pl-4">
  Using `#` is actually the best practice, because it leverages **Node.js**'s native subpath imports ‚éØ
  entries in the "imports" field of your package.json must start with `#` to distinguish them from package specifiers,
  so `import foo from '#src/foo.js'` works out-of-the-box across **Node**, test runners, and bundlers without plugins or polyfills.

  In contrast, @-based aliases (e.g. `@/src`) must be manually configured for each tool ‚éØ
  **Vite** requires explicit setup in the configuration file (and matching paths in tsconfig.json),
  while **Webpack**, **ESLint**, and others similarly demand custom overrides.

  Additionally, `@` overlaps with npm's scoped-package syntax (`@scope/pkg`),
  but `#` is reserved for internal subpath imports and can't clash with external packages,
  ensuring consistent resolution and a unified setup across your entire toolchain
  (i.e., you can now also use `#` in your build tool configuration files without hassle!)

  Since using `#` is best practice, we currently don't consider using any other symbol in our code and setup.
  <br/>
</div>
</details>

Now follow the steps below to set up the corresponding files:

<details className="tw:cursor-pointer">
<summary>tsconfig.json</summary>
  <div>
  Usually you will have this **TypeScript** file, but the name can be slightly different (e.g., maybe it's called `tsconfig.app.json`) depends on your choice of scaffolding tool (e.g., **Vite**, **Webpack**, ‚Ä¶).
  ```json
  {
    "compilerOptions": {
      "paths": {
        "#/*": ["app/*"], // doesn't need to be `app`, you may change it to whatever you want (e.g., `src`)
        // ...
      },
      // ...
    },
    // ...
  }
  ```
  </div>
</details>

<details className="tw:cursor-pointer">
  <summary>the build tool configuration file</summary>
  <div className="tw:pl-4">
  This means that you're using something like **Vite** or **Webpack**, so you need to tell it what `#` means to allow it to analyze and/or compile correctly. Below is an example for **Vite**, but this is extremely common and easy to do in all other build tools:
  ```ts
  // ...
  import tsconfigPaths from "vite-tsconfig-paths";
  export default defineConfig({
    plugins: [
      // ...
      tsconfigPaths()
    ],
    // ....
  });
  ```
  </div>
</details>

<details className="tw:cursor-pointer">
<summary>package.json</summary>
<div>
  ```json
  {
    "imports": {
      "#/*": "./app/*" // doesn't need to be `app`, you may change it to whatever you want (e.g., `src`)
      // ...
    },
    // ...
  }
  ```
  </div>
</details>

<br/>

### 2Ô∏è‚É£ &nbsp; Configure path preferences on this site

Many of our code examples have import statements with certain paths,
so if those code samples use path preferences that don't match your local environment setup,
how can you use ours in your project without hassle or refactoring?

That's why you need to do this here, so that all our code shown on this site will use the same setup as yours!

So our code currently would only have two path preferences (and probably will not have more in the future),
so please follow the instructions below to MAKE SURE they match your local environment setup:

<HelpersPathSection />

<ComponentsPathSection />

<br/>

### 3Ô∏è‚É£ &nbsp; Download **<u>Uitimate</u>**'s base dependencies
Since our code uses some dependencies under the hood, you need to install them in your project:

<TerminalCommandInstructor cli="npm add clsx tailwind-merge tailwind-variants tailwindcss-animate lodash-es change-case" />

<br/>

### 4Ô∏è‚É£ &nbsp; Configure **Tailwind**
Make sure you've setup the **Tailwind** v4 in your project, and copy the following configuration for **Tailwind** to a CSS file. Where this file should be executed,
where it should be placed, and even what its name should be are up to you, but make sure it's used in the project
(typically it should be imported in the application entry file),
otherwise all our components in your project will look UGLY!

```tsx file=./../style/core.css
```

<br />

<Banner>
Notice that we use the prefix `tw` in the code above (i.e., stands for **Tailwind**), which is the best practice:
now any of your **Tailwind** classes can only be used by prepending `tw:` (e.g., `tw:text-center`).
</Banner>

<br/>

### 5Ô∏è‚É£ &nbsp; Party time &nbsp; üéâ
Now, just head to any of our component pages to take a look,
and if you're willing to use that component, go to its "setup page" to follow the instructions there,
and just start to play with **Uitimate**!



